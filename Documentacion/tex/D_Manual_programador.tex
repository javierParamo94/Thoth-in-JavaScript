\apendice{Documentación técnica de programación}

\section{Introducción}

En esta sección se hablara de aspectos más técnicos pensando en futuros desarrollos. Sirve como ayuda para entender el funcionamiento de la aplicación y de los pasos que se han llevado a cabo para conseguir estos resultados. Se habla de la estructura del programa, de la instalación y configuración de las herramientas necesarias y del proyecto y, por último, de las pruebas realizadas.

\section{Estructura de directorios}

\section{Manual del programador}


\subsection{Instalación y configuración de GWT:}


Para poder trabajar con GWT \footnote{\url{http://www.oracle.com/technetwork/java/javase/downloads/index.html}}, se debe descargar el SDK de GWT proporcionado en la página web oficial. Los requisitos previos para crear un aplicación web con Google Web Toolkit son básicamente dos: tener instalada la SDK de Java en su versión 1.6 o cualquiera superior a esta y tener instalado también Apache Ant o en su defecto Apache Maven.

En mi caso, como trabajo con la plataforma Eclipse (versión 4.4.) al descargar el plugin de Google para Eclipse, este viene con GWT y la App Engine SDK, todo junto. Se puede descargar desde la siguiente dirección \footnote{\url{http://www.gwtproject.org/usingeclipse.html}}.

Para instalar el plugin desde eclipse, solo tenemos que ir a <<help>> y en el desplegable elegir la opción <<Instal new software>>. Aparecerá una ventana con un recuadro en el que pone <<work with>> y nos da la opción de escribir una dirección web. Para consultar las direcciones según la versión de Eclipse sólo tiene que visitar \url{https://developers.google.com/eclipse/docs/download}.
Aparecerá los elementos que se pueden instalar, y ahí elegimos el plugin de Google. Debemos esperar a que se instale y ya solo hará falta reiniciar Eclipse.

Como último paso, se debe referenciar la SDK de GWT y completar la instalación. Para habrá que ir a la opción <<window>> de la pantalla principal, hacer click en preferencias y aparecerá una ventana con varias opciones. Buscamos la opción de Google y en <<web toolkit>> y ahí añadir la referencia a la SDK con la dirección en la que se encuentra el archivo. Lo mismo hay que hacer para el <<App Engine>> pero en este caso añadiendo la referencias al App Engine.

El modo de trabajar con GWT es muy simple. Desde el plugin podemos crear un nuevo proyecto dese <<New Web Application Project>>, darle un nombre y marcando las opciones del SDK y el App Engine.

 
\subsection{Parser JavaCC}

GWT esta compuesto por una parte cliente, que es la que será traducida a JavaScript, y otra servidor escrita en Java y que no se traducirá. En un principio se prueba a incluir toda la aplicación dentro del lado del cliente, traduciendo todo a JavaScript. Pero como ya se ha dicho en otros apartados, GWT sólo soporta unas determinadas librerías en dicho lado y tiene algunas restricciones más\footnote{\url{http://www.gwtproject.org/doc/latest/DevGuideCodingBasicsCompatibility.html}.} que obligan a incluir el parser de JavaCC en el servidor, en vez del cliente.

Originalmente en el núcleo de Thoth, dentro del directorio <<grammar>>, colgaba un sub-directorio llamado <<parserjavacc>> en el cual se encontraba el parser para la gramática. Es la parte más importante a lo que a la gramática se refiere, ya que permite reconocer si una gramática está bien construida o no.


\subsection{Comunicación cliente-servidor}
Una vez alojado en el servidor el parser habrá que establecer una comunicación entre la parte del ciente en la que habrá un método que llame a la funcionalidad que se desee del servidor.

Para hacerlo, GWT utiliza la técnica denominada por sus siglas en inglés RPC o llamada de procedimiento remoto (Remote Procedure Call) que tiene una estructura similar a la siguiente ilustración \ref{fig:5.1}.

\begin{figure}[h]
\centering
\includegraphics[width=0.65\textwidth]{RPC}
\caption{Arquitectura RPC simple. Fuente propia.}
\label{fig:5.1}
\end{figure}

Del lado del cliente tenemos, en este caso, una interfaz gráfica de usuario (GUI), una clase dedicada a hacer las llamadas RPC (ClienImpl), dos interfaces que definen los métodos (Service y ServiceAsync), una clase con los métodos en el lado del servidor (serviceImpl) y por último una interfaz, que no es esencialmente necesaria (ClientInterface). 

En términos generales, para utilizar el parser de la gramática, que es quizá la clave de todo, hay que llamar al servidor y establecer una comunicación. Es ahí donde utilizamos la clase <<GrmmarServiceClientImp>> que hace las llamadas a las interfaces necesarias hasta llegar al servidor. Esta clase es un nexo de unión entre la parte del núcleo, que ese encuentra en el servidor, y la parte del cliente, que contiene lo visual y las acciones de los botones entre otros. La comunicación queda representada en este diagrama\ref{fig:5.2}.

\begin{figure}[h]
\centering
\includegraphics[width=1.1\textwidth]{ParserDiagram}
\caption{Diagrama sobre la comunicación entre el cliente y el servidor en GWT.}
\label{fig:5.2}
\end{figure}

Dentro de la clase <<GrammarServiceClientImp>> hay tres constructores según le pasemos una gramática, un texto, simplemente nada. El atributo url es simplemente la localización del <<servlet>> que se utiliza para la comunicación RPC. Estos detalles se aprecian mejor en el diagrama de clases que muestra la siguiente imagen \ref{fig:5.3}.

\begin{figure}
\raggedleft
\includegraphics[scale=0.9]{Parser-ClassDiagram}
\caption{Diagrama de clases que muestra como utiliza el parser de la gramática. Diagrama realizado con ObjectAid.}
\label{fig:5.3}
\end{figure}

Una vez hechos todos estos pasos, es posible que no funciona nada, es más, dará un error del tipo \textit{did you forget to inherit a required module?}. Todos los errores parecidos a este tienen que ver con el archivo <<web.xml>> que se encuentra en todos los proyectos GWT dentro de la carpeta <<war>> en <<WEB-INF>>. En ese archivo tenemos que definir los <<servlets>>, dándolos un nombre y especificando la dirección, dentro del proyecto, donde se encuentran. Después deberemos indicar la dirección del patrón, es decir indicar a que módulo pertenecen y con que nombre. Ese nombre se lo especificamos anteriormente en la interfaz <<GrammarService>> con el componente <<@RemoteServiceRelativePath(``nombre'')>>.

\section{Compilación, instalación y ejecución del proyecto}

Hace unos años Google contaba con un plugin para algunos navegadores (Chrome y Firefox) con los que se podía ejecutar el proyecto. Pero Google paró hace unos años el mantenimiento de este plugin. Pero afortunadamente los desarrolladores de GWT crearon <<GWT Super-Dev Mode>> que permite ejecutar y hacer <<debug>>. Con respecto a esto, es importante que para permitir este tipo de ejecución, debemos incluir una sentencia en la definición del módulo que se vaya a ejecutar.

Es decir, los proyectos en GWT pueden estar compuestos por varios módulos, que se ejecutarán cada vez que se les llame. Estos módulos llamarán a su vez una clase, digamos, principal del módulo. Esta clase debe implementar <<EntryPoint>> que indica que es la clase de <<entrada>> y debe tener un método denominado <<onModuleLoad>>. Es igual que el <<main>> en Java.

Como iba diciendo, en la definición del módulo, para poder realizar la ejecución con <<Super-Dev Mode>> debemos incluir la sentencia \textit{add-linker name=``xsiframe''}. Las definiciones de los módulos se encuentran en la raíz de la carpeta principal y tienen una extensión <<.gwt.xml>>.

\section{Pruebas del sistema}
